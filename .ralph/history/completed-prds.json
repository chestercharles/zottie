[
  {
    "name": "Landing page",
    "description": "Unauthenticated users are presented with a landing page when the open the application. The landing page should have a sign up and sign in button.",
    "completed": true
  },
  {
    "name": "Sign up",
    "description": "Users can sign up for an account using SSO (Google, Apple, etc.). We can use Auth0's universal login page for this - there is a react-native-auth0 package that can be used to authenticate users.",
    "completed": true
  },
  {
    "name": "Sign in",
    "description": "Users can sign in using SSO (Google, Apple, etc.). We can use Auth0's universal login page for this - there is a react-native-auth0 package that can be used to authenticate users.",
    "completed": true
  },
  {
    "name": "Create a staple pantry item",
    "description": "Users can create a staple pantry item by entering a name and status. The status defaults to 'in stock' but can be changed to 'running low' or 'out of stock'. The staple pantry item is added to the user's list of staple pantry items.",
    "completed": true
  },
  {
    "name": "View all staple pantry items",
    "description": "Users can view a list of all staple pantry items. The staple pantry items are displayed in a list.",
    "completed": true
  },
  {
    "name": "View a staple pantry item",
    "description": "Users can view a staple pantry item clicking on the item from the list of staple pantry items. The staple pantry item is displayed in a detail view. The user can easily return to the list of staple pantry items.",
    "completed": true
  },
  {
    "name": "Update a staple pantry item",
    "description": "Users can update the status of a staple pantry item on the staple panty item detail page. The status can be changed from 'in stock' to 'running low' to 'out of stock' and vice versa.",
    "completed": true
  },
  {
    "name": "Delete a staple pantry item",
    "description": "Users can delete a staple pantry item by entering a name. The staple pantry item is deleted from the user's list of staple pantry items.",
    "completed": true
  },
  {
    "name": "Users should be able to navigate between the pantry tab and the shopping tab",
    "description": "Users should be able to navigate between the pantry tab and the shopping tab using a bottom tab bar. The bottom tab bar should be displayed at the bottom of the screen. There is no need for a home screen.",
    "completed": true
  },
  {
    "name": "Shopping tab displays items to purchase",
    "description": "The shopping tab shows a unified list of all items that need to be purchased: staple items that are 'running low' or 'out of stock', plus all planned items that haven't been purchased yet. Each item displays its name, status (e.g., 'Running Low', 'Out of Stock', 'Planned'), and whether it is a staple or planned item. Items are mixed together in a single list.",
    "completed": true
  },
  {
    "name": "Check off items while shopping",
    "description": "Users can check off items in the shopping tab as they shop (e.g., as they put items in their cart). Checkmarks persist until the user explicitly unchecks them, resets the list, or marks items as purchased. Navigating away or closing the app does not clear checkmarks.",
    "completed": true
  },
  {
    "name": "Pantry screen shows planned items in a collapsible section",
    "description": "The pantry screen displays planned items in a separate collapsible section at the top of the screen. This section is collapsed by default. Staple items are displayed below in the main list. This allows users to focus on 'what I have now' (staples) while keeping planned items accessible.",
    "completed": true
  },
  {
    "name": "Shopping tab empty state",
    "description": "When the shopping tab has no items to display (all staples are in stock and no planned items exist), show a friendly empty state message like 'You're all set!' with a prompt to add planned items.",
    "completed": true
  },
  {
    "name": "Add planned item from shopping tab",
    "description": "Users can add a planned item directly from the shopping tab by entering a name. The planned item immediately appears on the shopping list (unchecked) and in the pantry's planned section with status 'planned'. Planned items represent one-time purchases that will be removed from the pantry once used up.",
    "completed": true
  },
  {
    "name": "Mark checked items as purchased",
    "description": "Users can mark all checked-off items as purchased with a single action. When purchased: staple items have their status changed to 'in stock', and planned items have their status changed to 'in stock'. All purchased items are removed from the shopping list. Unchecked items remain on the shopping list for the next shopping trip.",
    "completed": true
  },
  {
    "name": "Reset shopping list checkmarks",
    "description": "Users can reset the shopping list to uncheck all items. A confirmation dialog is shown before resetting. This is useful if the user wants to start fresh without marking anything as purchased.",
    "completed": true
  },
  {
    "name": "Item detail page accessible from shopping list",
    "description": "Users can tap on any item in the shopping list to navigate to that item's detail page. This is the same detail page accessible from the pantry. From the detail page, users can edit the item name, change status, or delete the item.",
    "completed": true
  },
  {
    "name": "Planned item lifecycle and removal",
    "description": "Planned items follow this lifecycle: Planned (not yet purchased) -> In Stock (purchased) -> Running Low -> Out of Stock (removed). When a user changes a planned item's status to 'out of stock', a confirmation dialog appears asking if they want to remove the item from their pantry. Upon confirmation, the planned item is permanently deleted. This differs from staples, which remain in the pantry and cycle back to the shopping list when out of stock.",
    "completed": true
  },
  {
    "name": "Edit pantry item name",
    "description": "Users can edit the name of any pantry item (staple or planned) from the item detail page at any time.",
    "completed": true
  },
  {
    "name": "Delete planned item",
    "description": "Users can delete a planned item entirely from the item detail page. This removes it from both the pantry and the shopping list. A confirmation dialog is shown before deletion.",
    "completed": true
  },
  {
    "name": "Record purchase date",
    "description": "When items are marked as purchased, the current date is recorded as the 'last purchased' date. This date is stored in the database and displayed on the item detail page.",
    "completed": true
  },
  {
    "name": "Pull to refresh pantry screen",
    "description": "Users can pull down on the pantry screen to refresh the list of pantry items from the database.",
    "completed": true
  },
  {
    "name": "Create a household",
    "description": "Users create a household through the onboarding flow by entering a household name. The POST /api/household endpoint creates the household with the provided name and adds the user as a member. The previous auto-creation behavior (where GET /api/household would create a household if none existed) is removed. A new GET /api/household/membership endpoint returns the user's household if they have one, or 404 if they don't (no auto-creation). The household name is required and can be edited later from the settings page.",
    "completed": true
  },
  {
    "name": "First-time user household onboarding flow",
    "description": "After a new user authenticates for the first time, they see an onboarding screen before accessing the main app. The screen presents two options: 'Create a Household' (primary) with a required text input for household name, and 'Join an Existing Household' (secondary) which displays a message explaining that they need an invite link from someone else. When creating a household, the user enters a name and taps 'Create Household' to create their household and proceed to the pantry. The app detects first-time users by checking if they have a household membership (via GET /api/household/membership which returns 404 if no household exists). Users without a household are redirected to the onboarding screen and cannot access other authenticated screens until onboarding is complete.",
    "completed": true
  },
  {
    "name": "Generate household invite link",
    "description": "From the settings page, users can generate a shareable invite link to invite others to their household. The link expires after 7 days. Users can generate a new link at any time (which invalidates any previous unexpired link). The link can be shared via the device's native share sheet.",
    "completed": true
  },
  {
    "name": "Handle invite deep links",
    "description": "When a user opens a zottie://join/{code} link, the app routes to a join screen that validates the invite code via GET /api/household/invite/{code} and displays the target household name. If the invite is invalid or expired, shows an error message. If the user is not authenticated, prompts them to sign in/sign up first and stores the invite code so the join flow can resume after auth.",
    "completed": true
  },
  {
    "name": "New user joins household via invite",
    "description": "On the join screen, authenticated users without a household see the target household name and a 'Join Household' button. Tapping the button calls POST /api/household/join/{code} to add them to the household, then navigates to the pantry (skipping the normal create-household onboarding flow).",
    "completed": true
  },
  {
    "name": "Existing user switches household via invite",
    "description": "On the join screen, authenticated users who already have a household see a warning that joining will remove them from their current household. If the invite is for their current household, shows 'You're already a member.' Otherwise, shows 'Switch Households' and 'Cancel' options. On confirmation, removes them from their current household and adds them to the new one via POST /api/household/join/{code}.",
    "completed": true
  },
  {
    "name": "Pantry items scoped to household",
    "description": "Pantry items belong to a household rather than an individual user. All members of a household see the same pantry items. Any member can create, update, or delete pantry items. This replaces the current user-scoped pantry item model.",
    "completed": true
  },
  {
    "name": "Shopping list scoped to household",
    "description": "The shopping list is derived from household pantry data. All members see the same shopping list. Any member can check off items and mark items as purchased. Changes are visible to other members on refresh.",
    "completed": true
  },
  {
    "name": "Settings page accessible from pantry screen",
    "description": "A settings gear icon is displayed in the header of the pantry screen. Tapping the gear navigates the user to a settings page where they can manage their account and household settings.",
    "completed": true
  },
  {
    "name": "Log out from settings page",
    "description": "Users can log out of their account from the settings page. A 'Log Out' button is prominently displayed. Tapping it shows a confirmation dialog, and upon confirmation, the user is logged out and returned to the login/welcome screen.",
    "completed": true
  },
  {
    "name": "Leave a household",
    "description": "Users can leave their current household from the settings page. When leaving: a new empty household is created for them, and they start fresh with no pantry or shopping data. If they were the last member, the old household and all its data is permanently deleted. A confirmation dialog is shown before leaving.",
    "completed": true
  },
  {
    "name": "Settings page displays household info and members",
    "description": "The settings page displays the user's household name (editable) and lists all current household members. Each member is displayed with their name or email, and the current user is indicated (e.g., with a 'You' label). If no custom name has been set, the default household name is shown.",
    "completed": true
  },
  {
    "name": "Purchased planned items display in pantry list",
    "description": "Planned items that have been purchased and are now in stock should display in the main pantry list alongside staples, not in the collapsible planned items section. Only planned items that haven't yet been purchased (status 'planned') should appear in the compressed planned items section at the top of the pantry screen.",
    "completed": true
  },
  {
    "name": "Filter pantry items by search term",
    "description": "A search box is displayed at the top of the pantry screen. As the user types, the pantry list filters in real-time to show only items whose name contains the search term (case-insensitive). A clear button (X icon) appears in the search box when text is entered. Tapping the clear button removes the search term and shows all pantry items again. The search filters both the main pantry list and the planned items section.",
    "completed": true
  },
  {
    "name": "Users should be able to log out from the onboarding screen",
    "description": "Users should be able to log out from the onboarding screen. The onboarding screen should have a 'Log Out' button that logs the user out and returns them to the landing page. The button should be displayed near the bottom of the screen.",
    "completed": true
  },
  {
    "name": "Visual indicator distinguishes planned items from staples",
    "description": "In the main pantry list, planned items display a small icon next to their name to visually distinguish them from staple items. This helps users quickly identify which items are one-time planned purchases vs recurring staples. The icon should be subtle and not interfere with readability. This applies to planned items that appear in the main list (those with status 'in_stock' or 'running_low'), not to items in the collapsible 'Planned Items' section which are already clearly grouped.",
    "completed": true
  },
  {
    "name": "Swipe actions for quick status changes on pantry items",
    "description": "Users can swipe left on pantry items to reveal a button that opens an iOS action sheet with contextual options. For staple items, the action sheet shows: 'Mark as Running Low', 'Mark as Out of Stock', 'Delete Item', and Cancel. For planned items, the action sheet shows: 'Mark as Running Low', 'Finished - Remove from Pantry', 'Finished - Convert to Staple', 'Delete Item', and Cancel. The 'Finished - Remove from Pantry' option removes the planned item entirely. The 'Finished - Convert to Staple' option changes the item's type to 'staple' and sets its status to 'out_of_stock' so it appears on the shopping list for re-purchase. This replaces the confusing behavior where tapping 'Out of Stock' on a planned item would trigger a removal confirmation.",
    "completed": true
  },

  {
    "name": "iOS-style bottom sheet for adding pantry items",
    "description": "Replace the current FAB (floating action button) and full-screen form with an iOS-native bottom sheet pattern. A '+' button appears in the pantry screen's header bar (next to the settings icon). Tapping it opens a bottom sheet that slides up from the bottom of the screen. The sheet contains: a text input for item name (autofocused), a status selector with options 'In Stock' (default), 'Running Low', and 'Out of Stock', and an 'Add' button. The sheet can be dismissed by swiping down or tapping the backdrop. This replaces the current navigation to /pantry/create.",
    "completed": true
  },
  {
    "name": "Full-screen add item sheet for pantry (iOS Calendar style)",
    "description": "Enhance the pantry add-item bottom sheet to follow the iOS Calendar 'new event' pattern. The sheet should expand to full screen height. Replace the current header/controls with: an X button in the top left corner to dismiss the sheet, and a checkmark button in the top right corner to add the item (replacing the current 'Add' button at the bottom). The text input and status selector remain in the body of the sheet. This provides a more spacious, focused experience for adding items and follows established iOS patterns.",
    "completed": true
  },
  {
    "name": "iOS-style bottom sheet for adding shopping list items",
    "description": "Replace the current inline text input at the top of the shopping list with an iOS-native full-screen bottom sheet pattern that matches the pantry add-item experience. A '+' button appears in the shopping screen's header bar. Tapping it opens a full-screen bottom sheet (iOS Calendar style). The sheet has: an X button in the top left corner to dismiss, a checkmark button in the top right corner to add the item, and a text input for item name (autofocused) in the body. The status is always 'planned' so no selector is shown. This provides consistency with the pantry add-item UX.",
    "completed": true
  },
  {
    "name": "Native iOS swipe actions for pantry list",
    "description": "Refactor the pantry list to use native-feeling iOS swipe actions. Replace the deprecated Swipeable component with ReanimatedSwipeable from react-native-gesture-handler/ReanimatedSwipeable. Replace the current ellipsis button pattern with direct labeled action buttons that appear on swipe, similar to iOS Mail. For staple items, show: 'Low' (orange, marks as running low), 'Out' (red, marks as out of stock). For all items, show 'Delete' (red) as a destructive action on the far right. Add haptic feedback using expo-haptics when swipe actions are triggered. Support full-swipe gesture to execute the primary action (mark as running low) without requiring a tap. The action buttons should have icons and short labels. Keep ActionSheetIOS as a fallback for less common actions accessible via a 'More' button if needed.",
    "completed": true
  },
  {
    "name": "Migrate pantry list to FlatList",
    "description": "Replace ScrollView with FlatList in PantryListScreen for better performance and consistency with ShoppingListScreen. Extract the PantryItemRow component to work with FlatList's renderItem pattern. Maintain the existing planned items collapsible section as a ListHeaderComponent or SectionList section. Ensure pull-to-refresh continues to work with RefreshControl. This improves scroll performance for users with many pantry items and aligns with React Native best practices for lists.",
    "completed": true
  },
  {
    "name": "Native iOS swipe actions for shopping list",
    "description": "Add native-feeling iOS swipe actions to the shopping list, consistent with the pantry list implementation. Use ReanimatedSwipeable from react-native-gesture-handler/ReanimatedSwipeable. Swipe left to reveal: 'Purchased' (green, marks single item as purchased immediately) and 'Delete' (red, removes the item). Add haptic feedback using expo-haptics when swipe actions are triggered. Support full-swipe gesture to execute the primary action (mark as purchased). The existing checkbox pattern remains for batch operations, but swipe provides a quick single-item action. This complements the pantry swipe actions and provides a consistent interaction model across both lists.",
    "completed": true
  },
  {
    "name": "Deleteing a pantry item should only be possible from the item detail page",
    "description": "Deleteing a pantry item should only be possible from the item detail page. The delete button should be visible at the bottom of the item detail page. The delete button should open a confirmation dialog before deleting the item. The confirmation dialog should have a Cancel and Delete button. The Delete button should be destructive and should delete the item immediately. The Cancel button should close the confirmation dialog and should not delete the item. Users should not be able to delete a pantry item from the pantry list screen.",
    "completed": true
  },
  {
    "name": "Onboarding quick-add inventory screen",
    "description": "Create a new onboarding screen that displays common pantry items grouped by category (vegetables, fruits, baking, proteins, dairy, pantry staples, etc.). The curated list should be hardcoded in the frontend. Users can tap items to select/deselect them. All selected items default to 'in_stock' status - users can adjust status later in the pantry if needed. After confirming selections, users are taken to their pantry screen with the items added. Users can skip this step to start with an empty pantry. This screen is only shown during onboarding and is not accessible later.",
    "completed": true
  },
  {
    "name": "Commands tab screen dictation",
    "description": "Create a new tab screen with a clean UI featuring a microphone button. When pressed, the app records speech and transcribes it using a speech-to-text library. The transcription is not shown to the user - instead, it is sent directly to the parsing backend endpoint. The screen should not show command history - just the mic button when idle. Add an appropriate speech-to-text library (evaluate expo-speech-recognition or react-native-voice for best fit).",
    "completed": true
  },
  {
    "name": "Commands tab screen execution",
    "description": "After the parsing endpoint returns, display the parsed actions to the user in a simple list format (e.g., 'Add apples to pantry (in stock)', 'Mark milk as running low') with confirm and cancel buttons. When the user confirms, send the actions to the execution endpoint. On successful execution, invalidate the pantry and shopping list queries to refresh data. Handle loading states appropriately during parsing and execution.",
    "completed": true
  },
  {
    "name": "Commands parsing backend endpoint",
    "description": "Create a backend endpoint that processes natural language commands using OpenAI. The endpoint should fetch the user's current pantry and shopping list for context, then use the AI to determine the actions needed to fulfill the command. Supported actions: add an item to the pantry, mark an item as running low, mark an item as out of stock, add an item to the shopping list, remove an item from the shopping list. The endpoint returns a list of actions in a structured format (e.g., { actions: [{ type: 'add_to_pantry', item: 'apples', status: 'in_stock' }] }). Be smart about user intent - if a user says 'mark apples as running low' but apples aren't in the pantry, add them with running_low status rather than returning an error. The app should meet users where they are.",
    "completed": true
  },
  {
    "name": "Commands execution backend endpoint",
    "description": "Create a backend endpoint that executes the actions sent by the frontend. The actions should be in the same structured format as the response from the parsing endpoint, allowing execution to be tested independently of parsing. The endpoint executes each action (adding pantry items, updating statuses, modifying shopping list) and returns a success/failure response.",
    "completed": true
  },
  {
    "name": "Commands parsing empathetic error responses",
    "description": "When the commands parsing endpoint cannot identify any actions from user input, replace the generic 'no actions found in your command. please try again' error with a helpful, empathetic response. The response should explain why we couldn't understand the input (e.g., 'I couldn't find any pantry or shopping list actions in that command'), and provide a recommendation for what to do next based on the context of what the user said. Try to understand what the user might have meant and guide them toward success. The tone should be validating and supportive (acknowledging their effort) without being patronizing or elitist. This follows the pattern of the 'Try saying' section, which helps users feel in control and understand how to use the app effectively.",
    "completed": true
  },
  {
    "name": "Commands dictation manual stop",
    "description": "Allow users to manually stop recording by pressing the microphone button again while recording is in progress. When pressed during recording, the button should stop the speech recognition, submit the captured audio for transcription, and proceed with command parsing. This provides users with control over when their command is complete, rather than relying solely on automatic silence detection.",
    "completed": true
  },
  {
    "name": "Commands dictation automatic timeout",
    "description": "Configure automatic timeout behavior for speech recognition to stop recording after a reasonable period of silence. On iOS, the platform handles this automatically (3 seconds on iOS 17 and earlier, until final result on iOS 18+). On Android, configure androidIntentOptions with EXTRA_SPEECH_INPUT_COMPLETE_SILENCE_LENGTH_MILLIS and EXTRA_SPEECH_INPUT_POSSIBLY_COMPLETE_SILENCE_LENGTH_MILLIS to control silence detection timing. The goal is to stop recording naturally when the user pauses speaking, without requiring manual intervention.",
    "completed": true
  },
  {
    "name": "Commands dictation recording animation",
    "description": "Add a subtle animation to the microphone button while recording is in progress to provide visual feedback that the app is actively listening. Follow iOS design patterns for recording indicators: use a gentle pulsing or breathing animation (scale transform with spring physics) on the button. The animation should be continuous and smooth, using iOS-native spring physics (withSpring in react-native-reanimated) rather than linear timing. Keep the animation subtle to avoid being distracting - the goal is to provide ambient awareness that recording is active.",
    "completed": true
  },
  {
    "name": "Commands dictation stop feedback",
    "description": "Provide immediate feedback when recording stops (either manually or automatically). Add a subtle animation to the microphone button (a brief scale-down spring animation) and play a short system sound to indicate recording has ended. For the sound, use iOS system sounds via expo-av or react-native-sound - choose a gentle, non-intrusive sound similar to the iOS keyboard click or message send sound. The animation and sound should happen together to create a cohesive 'recording complete' moment. Follow iOS patterns for this type of feedback - brief, subtle, and reassuring rather than loud or jarring.",
    "completed": true
  },
  {
    "name": "Onboarding feature flag API endpoint",
    "description": "Create a backend API endpoint that returns which onboarding experience to show (original vs new conversational onboarding). The endpoint reads from a hardcoded text file in the repo (e.g., config/onboarding-flag.txt) that contains either 'original' or 'conversational'. This allows us to toggle between onboarding experiences by manually editing the text file and deploying, without needing to rebuild the mobile app. The mobile app calls this endpoint before showing onboarding to determine which flow to use.",
    "completed": true
  },
  {
    "name": "Onboarding text parsing backend endpoint",
    "description": "Create a backend endpoint that parses natural language text into pantry items and/or shopping list items using OpenAI. The endpoint accepts text input and context about what the user is describing (injected into the prompt - e.g., 'the user is listing what they have in their pantry' or 'the user is listing what they need from the store'). The endpoint can parse either type or both from the same message. For pantry items, create them with 'in_stock' status. For shopping items, create them as planned shopping list items. Return a structured response indicating what was created (e.g., { pantryItems: [...], shoppingItems: [...] }). The endpoint creates these items in the database for the user's household. Handle the case where the user explicitly says they have nothing to add (return empty lists, not an error). Return an error only if the text is unclear or completely unrelated to pantry/shopping items.",
    "completed": true,
    "note": "Decision made to reuse existing /api/commands/parse and /api/commands/execute endpoints instead of creating a separate onboarding-specific endpoint. Frontend will format user input as commands (e.g., 'add milk, eggs, bread to pantry') and orchestrate the parse + execute flow."
  }
]
