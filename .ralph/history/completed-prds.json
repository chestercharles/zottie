[
  {
    "name": "Landing page",
    "description": "Unauthenticated users are presented with a landing page when the open the application. The landing page should have a sign up and sign in button.",
    "completed": true
  },
  {
    "name": "Sign up",
    "description": "Users can sign up for an account using SSO (Google, Apple, etc.). We can use Auth0's universal login page for this - there is a react-native-auth0 package that can be used to authenticate users.",
    "completed": true
  },
  {
    "name": "Sign in",
    "description": "Users can sign in using SSO (Google, Apple, etc.). We can use Auth0's universal login page for this - there is a react-native-auth0 package that can be used to authenticate users.",
    "completed": true
  },
  {
    "name": "Create a staple pantry item",
    "description": "Users can create a staple pantry item by entering a name and status. The status defaults to 'in stock' but can be changed to 'running low' or 'out of stock'. The staple pantry item is added to the user's list of staple pantry items.",
    "completed": true
  },
  {
    "name": "View all staple pantry items",
    "description": "Users can view a list of all staple pantry items. The staple pantry items are displayed in a list.",
    "completed": true
  },
  {
    "name": "View a staple pantry item",
    "description": "Users can view a staple pantry item clicking on the item from the list of staple pantry items. The staple pantry item is displayed in a detail view. The user can easily return to the list of staple pantry items.",
    "completed": true
  },
  {
    "name": "Update a staple pantry item",
    "description": "Users can update the status of a staple pantry item on the staple panty item detail page. The status can be changed from 'in stock' to 'running low' to 'out of stock' and vice versa.",
    "completed": true
  },
  {
    "name": "Delete a staple pantry item",
    "description": "Users can delete a staple pantry item by entering a name. The staple pantry item is deleted from the user's list of staple pantry items.",
    "completed": true
  },
  {
    "name": "Users should be able to navigate between the pantry tab and the shopping tab",
    "description": "Users should be able to navigate between the pantry tab and the shopping tab using a bottom tab bar. The bottom tab bar should be displayed at the bottom of the screen. There is no need for a home screen.",
    "completed": true
  },
  {
    "name": "Shopping tab displays items to purchase",
    "description": "The shopping tab shows a unified list of all items that need to be purchased: staple items that are 'running low' or 'out of stock', plus all planned items that haven't been purchased yet. Each item displays its name, status (e.g., 'Running Low', 'Out of Stock', 'Planned'), and whether it is a staple or planned item. Items are mixed together in a single list.",
    "completed": true
  },
  {
    "name": "Check off items while shopping",
    "description": "Users can check off items in the shopping tab as they shop (e.g., as they put items in their cart). Checkmarks persist until the user explicitly unchecks them, resets the list, or marks items as purchased. Navigating away or closing the app does not clear checkmarks.",
    "completed": true
  },
  {
    "name": "Pantry screen shows planned items in a collapsible section",
    "description": "The pantry screen displays planned items in a separate collapsible section at the top of the screen. This section is collapsed by default. Staple items are displayed below in the main list. This allows users to focus on 'what I have now' (staples) while keeping planned items accessible.",
    "completed": true
  },
  {
    "name": "Shopping tab empty state",
    "description": "When the shopping tab has no items to display (all staples are in stock and no planned items exist), show a friendly empty state message like 'You're all set!' with a prompt to add planned items.",
    "completed": true
  },
  {
    "name": "Add planned item from shopping tab",
    "description": "Users can add a planned item directly from the shopping tab by entering a name. The planned item immediately appears on the shopping list (unchecked) and in the pantry's planned section with status 'planned'. Planned items represent one-time purchases that will be removed from the pantry once used up.",
    "completed": true
  },
  {
    "name": "Mark checked items as purchased",
    "description": "Users can mark all checked-off items as purchased with a single action. When purchased: staple items have their status changed to 'in stock', and planned items have their status changed to 'in stock'. All purchased items are removed from the shopping list. Unchecked items remain on the shopping list for the next shopping trip.",
    "completed": true
  },
  {
    "name": "Reset shopping list checkmarks",
    "description": "Users can reset the shopping list to uncheck all items. A confirmation dialog is shown before resetting. This is useful if the user wants to start fresh without marking anything as purchased.",
    "completed": true
  },
  {
    "name": "Item detail page accessible from shopping list",
    "description": "Users can tap on any item in the shopping list to navigate to that item's detail page. This is the same detail page accessible from the pantry. From the detail page, users can edit the item name, change status, or delete the item.",
    "completed": true
  },
  {
    "name": "Planned item lifecycle and removal",
    "description": "Planned items follow this lifecycle: Planned (not yet purchased) -> In Stock (purchased) -> Running Low -> Out of Stock (removed). When a user changes a planned item's status to 'out of stock', a confirmation dialog appears asking if they want to remove the item from their pantry. Upon confirmation, the planned item is permanently deleted. This differs from staples, which remain in the pantry and cycle back to the shopping list when out of stock.",
    "completed": true
  },
  {
    "name": "Edit pantry item name",
    "description": "Users can edit the name of any pantry item (staple or planned) from the item detail page at any time.",
    "completed": true
  },
  {
    "name": "Delete planned item",
    "description": "Users can delete a planned item entirely from the item detail page. This removes it from both the pantry and the shopping list. A confirmation dialog is shown before deletion.",
    "completed": true
  },
  {
    "name": "Record purchase date",
    "description": "When items are marked as purchased, the current date is recorded as the 'last purchased' date. This date is stored in the database and displayed on the item detail page.",
    "completed": true
  },
  {
    "name": "Pull to refresh pantry screen",
    "description": "Users can pull down on the pantry screen to refresh the list of pantry items from the database.",
    "completed": true
  },
  {
    "name": "Create a household",
    "description": "Users create a household through the onboarding flow by entering a household name. The POST /api/household endpoint creates the household with the provided name and adds the user as a member. The previous auto-creation behavior (where GET /api/household would create a household if none existed) is removed. A new GET /api/household/membership endpoint returns the user's household if they have one, or 404 if they don't (no auto-creation). The household name is required and can be edited later from the settings page.",
    "completed": true
  },
  {
    "name": "First-time user household onboarding flow",
    "description": "After a new user authenticates for the first time, they see an onboarding screen before accessing the main app. The screen presents two options: 'Create a Household' (primary) with a required text input for household name, and 'Join an Existing Household' (secondary) which displays a message explaining that they need an invite link from someone else. When creating a household, the user enters a name and taps 'Create Household' to create their household and proceed to the pantry. The app detects first-time users by checking if they have a household membership (via GET /api/household/membership which returns 404 if no household exists). Users without a household are redirected to the onboarding screen and cannot access other authenticated screens until onboarding is complete.",
    "completed": true
  },
  {
    "name": "Generate household invite link",
    "description": "From the settings page, users can generate a shareable invite link to invite others to their household. The link expires after 7 days. Users can generate a new link at any time (which invalidates any previous unexpired link). The link can be shared via the device's native share sheet.",
    "completed": true
  },
  {
    "name": "Handle invite deep links",
    "description": "When a user opens a zottie://join/{code} link, the app routes to a join screen that validates the invite code via GET /api/household/invite/{code} and displays the target household name. If the invite is invalid or expired, shows an error message. If the user is not authenticated, prompts them to sign in/sign up first and stores the invite code so the join flow can resume after auth.",
    "completed": true
  },
  {
    "name": "New user joins household via invite",
    "description": "On the join screen, authenticated users without a household see the target household name and a 'Join Household' button. Tapping the button calls POST /api/household/join/{code} to add them to the household, then navigates to the pantry (skipping the normal create-household onboarding flow).",
    "completed": true
  },
  {
    "name": "Existing user switches household via invite",
    "description": "On the join screen, authenticated users who already have a household see a warning that joining will remove them from their current household. If the invite is for their current household, shows 'You're already a member.' Otherwise, shows 'Switch Households' and 'Cancel' options. On confirmation, removes them from their current household and adds them to the new one via POST /api/household/join/{code}.",
    "completed": true
  },
  {
    "name": "Pantry items scoped to household",
    "description": "Pantry items belong to a household rather than an individual user. All members of a household see the same pantry items. Any member can create, update, or delete pantry items. This replaces the current user-scoped pantry item model.",
    "completed": true
  },
  {
    "name": "Shopping list scoped to household",
    "description": "The shopping list is derived from household pantry data. All members see the same shopping list. Any member can check off items and mark items as purchased. Changes are visible to other members on refresh.",
    "completed": true
  },
  {
    "name": "Settings page accessible from pantry screen",
    "description": "A settings gear icon is displayed in the header of the pantry screen. Tapping the gear navigates the user to a settings page where they can manage their account and household settings.",
    "completed": true
  },
  {
    "name": "Log out from settings page",
    "description": "Users can log out of their account from the settings page. A 'Log Out' button is prominently displayed. Tapping it shows a confirmation dialog, and upon confirmation, the user is logged out and returned to the login/welcome screen.",
    "completed": true
  },
  {
    "name": "Leave a household",
    "description": "Users can leave their current household from the settings page. When leaving: a new empty household is created for them, and they start fresh with no pantry or shopping data. If they were the last member, the old household and all its data is permanently deleted. A confirmation dialog is shown before leaving.",
    "completed": true
  },
  {
    "name": "Settings page displays household info and members",
    "description": "The settings page displays the user's household name (editable) and lists all current household members. Each member is displayed with their name or email, and the current user is indicated (e.g., with a 'You' label). If no custom name has been set, the default household name is shown.",
    "completed": true
  },
  {
    "name": "Purchased planned items display in pantry list",
    "description": "Planned items that have been purchased and are now in stock should display in the main pantry list alongside staples, not in the collapsible planned items section. Only planned items that haven't yet been purchased (status 'planned') should appear in the compressed planned items section at the top of the pantry screen.",
    "completed": true
  },
  {
    "name": "Filter pantry items by search term",
    "description": "A search box is displayed at the top of the pantry screen. As the user types, the pantry list filters in real-time to show only items whose name contains the search term (case-insensitive). A clear button (X icon) appears in the search box when text is entered. Tapping the clear button removes the search term and shows all pantry items again. The search filters both the main pantry list and the planned items section.",
    "completed": true
  },
  {
    "name": "Users should be able to log out from the onboarding screen",
    "description": "Users should be able to log out from the onboarding screen. The onboarding screen should have a 'Log Out' button that logs the user out and returns them to the landing page. The button should be displayed near the bottom of the screen.",
    "completed": true
  },
  {
    "name": "Visual indicator distinguishes planned items from staples",
    "description": "In the main pantry list, planned items display a small icon next to their name to visually distinguish them from staple items. This helps users quickly identify which items are one-time planned purchases vs recurring staples. The icon should be subtle and not interfere with readability. This applies to planned items that appear in the main list (those with status 'in_stock' or 'running_low'), not to items in the collapsible 'Planned Items' section which are already clearly grouped.",
    "completed": true
  },
  {
    "name": "Swipe actions for quick status changes on pantry items",
    "description": "Users can swipe left on pantry items to reveal a button that opens an iOS action sheet with contextual options. For staple items, the action sheet shows: 'Mark as Running Low', 'Mark as Out of Stock', 'Delete Item', and Cancel. For planned items, the action sheet shows: 'Mark as Running Low', 'Finished - Remove from Pantry', 'Finished - Convert to Staple', 'Delete Item', and Cancel. The 'Finished - Remove from Pantry' option removes the planned item entirely. The 'Finished - Convert to Staple' option changes the item's type to 'staple' and sets its status to 'out_of_stock' so it appears on the shopping list for re-purchase. This replaces the confusing behavior where tapping 'Out of Stock' on a planned item would trigger a removal confirmation.",
    "completed": true
  },

  {
    "name": "iOS-style bottom sheet for adding pantry items",
    "description": "Replace the current FAB (floating action button) and full-screen form with an iOS-native bottom sheet pattern. A '+' button appears in the pantry screen's header bar (next to the settings icon). Tapping it opens a bottom sheet that slides up from the bottom of the screen. The sheet contains: a text input for item name (autofocused), a status selector with options 'In Stock' (default), 'Running Low', and 'Out of Stock', and an 'Add' button. The sheet can be dismissed by swiping down or tapping the backdrop. This replaces the current navigation to /pantry/create.",
    "completed": true
  },
  {
    "name": "Full-screen add item sheet for pantry (iOS Calendar style)",
    "description": "Enhance the pantry add-item bottom sheet to follow the iOS Calendar 'new event' pattern. The sheet should expand to full screen height. Replace the current header/controls with: an X button in the top left corner to dismiss the sheet, and a checkmark button in the top right corner to add the item (replacing the current 'Add' button at the bottom). The text input and status selector remain in the body of the sheet. This provides a more spacious, focused experience for adding items and follows established iOS patterns.",
    "completed": true
  },
  {
    "name": "iOS-style bottom sheet for adding shopping list items",
    "description": "Replace the current inline text input at the top of the shopping list with an iOS-native full-screen bottom sheet pattern that matches the pantry add-item experience. A '+' button appears in the shopping screen's header bar. Tapping it opens a full-screen bottom sheet (iOS Calendar style). The sheet has: an X button in the top left corner to dismiss, a checkmark button in the top right corner to add the item, and a text input for item name (autofocused) in the body. The status is always 'planned' so no selector is shown. This provides consistency with the pantry add-item UX.",
    "completed": true
  },
  {
    "name": "Native iOS swipe actions for pantry list",
    "description": "Refactor the pantry list to use native-feeling iOS swipe actions. Replace the deprecated Swipeable component with ReanimatedSwipeable from react-native-gesture-handler/ReanimatedSwipeable. Replace the current ellipsis button pattern with direct labeled action buttons that appear on swipe, similar to iOS Mail. For staple items, show: 'Low' (orange, marks as running low), 'Out' (red, marks as out of stock). For all items, show 'Delete' (red) as a destructive action on the far right. Add haptic feedback using expo-haptics when swipe actions are triggered. Support full-swipe gesture to execute the primary action (mark as running low) without requiring a tap. The action buttons should have icons and short labels. Keep ActionSheetIOS as a fallback for less common actions accessible via a 'More' button if needed.",
    "completed": true
  },
  {
    "name": "Migrate pantry list to FlatList",
    "description": "Replace ScrollView with FlatList in PantryListScreen for better performance and consistency with ShoppingListScreen. Extract the PantryItemRow component to work with FlatList's renderItem pattern. Maintain the existing planned items collapsible section as a ListHeaderComponent or SectionList section. Ensure pull-to-refresh continues to work with RefreshControl. This improves scroll performance for users with many pantry items and aligns with React Native best practices for lists.",
    "completed": true
  },
  {
    "name": "Native iOS swipe actions for shopping list",
    "description": "Add native-feeling iOS swipe actions to the shopping list, consistent with the pantry list implementation. Use ReanimatedSwipeable from react-native-gesture-handler/ReanimatedSwipeable. Swipe left to reveal: 'Purchased' (green, marks single item as purchased immediately) and 'Delete' (red, removes the item). Add haptic feedback using expo-haptics when swipe actions are triggered. Support full-swipe gesture to execute the primary action (mark as purchased). The existing checkbox pattern remains for batch operations, but swipe provides a quick single-item action. This complements the pantry swipe actions and provides a consistent interaction model across both lists.",
    "completed": true
  },
  {
    "name": "Deleteing a pantry item should only be possible from the item detail page",
    "description": "Deleteing a pantry item should only be possible from the item detail page. The delete button should be visible at the bottom of the item detail page. The delete button should open a confirmation dialog before deleting the item. The confirmation dialog should have a Cancel and Delete button. The Delete button should be destructive and should delete the item immediately. The Cancel button should close the confirmation dialog and should not delete the item. Users should not be able to delete a pantry item from the pantry list screen.",
    "completed": true
  },
  {
    "name": "Onboarding quick-add inventory screen",
    "description": "Create a new onboarding screen that displays common pantry items grouped by category (vegetables, fruits, baking, proteins, dairy, pantry staples, etc.). The curated list should be hardcoded in the frontend. Users can tap items to select/deselect them. All selected items default to 'in_stock' status - users can adjust status later in the pantry if needed. After confirming selections, users are taken to their pantry screen with the items added. Users can skip this step to start with an empty pantry. This screen is only shown during onboarding and is not accessible later.",
    "completed": true
  },
  {
    "name": "Commands tab screen dictation",
    "description": "Create a new tab screen with a clean UI featuring a microphone button. When pressed, the app records speech and transcribes it using a speech-to-text library. The transcription is not shown to the user - instead, it is sent directly to the parsing backend endpoint. The screen should not show command history - just the mic button when idle. Add an appropriate speech-to-text library (evaluate expo-speech-recognition or react-native-voice for best fit).",
    "completed": true
  },
  {
    "name": "Commands tab screen execution",
    "description": "After the parsing endpoint returns, display the parsed actions to the user in a simple list format (e.g., 'Add apples to pantry (in stock)', 'Mark milk as running low') with confirm and cancel buttons. When the user confirms, send the actions to the execution endpoint. On successful execution, invalidate the pantry and shopping list queries to refresh data. Handle loading states appropriately during parsing and execution.",
    "completed": true
  },
  {
    "name": "Commands parsing backend endpoint",
    "description": "Create a backend endpoint that processes natural language commands using OpenAI. The endpoint should fetch the user's current pantry and shopping list for context, then use the AI to determine the actions needed to fulfill the command. Supported actions: add an item to the pantry, mark an item as running low, mark an item as out of stock, add an item to the shopping list, remove an item from the shopping list. The endpoint returns a list of actions in a structured format (e.g., { actions: [{ type: 'add_to_pantry', item: 'apples', status: 'in_stock' }] }). Be smart about user intent - if a user says 'mark apples as running low' but apples aren't in the pantry, add them with running_low status rather than returning an error. The app should meet users where they are.",
    "completed": true
  },
  {
    "name": "Commands execution backend endpoint",
    "description": "Create a backend endpoint that executes the actions sent by the frontend. The actions should be in the same structured format as the response from the parsing endpoint, allowing execution to be tested independently of parsing. The endpoint executes each action (adding pantry items, updating statuses, modifying shopping list) and returns a success/failure response.",
    "completed": true
  },
  {
    "name": "Commands parsing empathetic error responses",
    "description": "When the commands parsing endpoint cannot identify any actions from user input, replace the generic 'no actions found in your command. please try again' error with a helpful, empathetic response. The response should explain why we couldn't understand the input (e.g., 'I couldn't find any pantry or shopping list actions in that command'), and provide a recommendation for what to do next based on the context of what the user said. Try to understand what the user might have meant and guide them toward success. The tone should be validating and supportive (acknowledging their effort) without being patronizing or elitist. This follows the pattern of the 'Try saying' section, which helps users feel in control and understand how to use the app effectively.",
    "completed": true
  },
  {
    "name": "Commands dictation manual stop",
    "description": "Allow users to manually stop recording by pressing the microphone button again while recording is in progress. When pressed during recording, the button should stop the speech recognition, submit the captured audio for transcription, and proceed with command parsing. This provides users with control over when their command is complete, rather than relying solely on automatic silence detection.",
    "completed": true
  },
  {
    "name": "Commands dictation automatic timeout",
    "description": "Configure automatic timeout behavior for speech recognition to stop recording after a reasonable period of silence. On iOS, the platform handles this automatically (3 seconds on iOS 17 and earlier, until final result on iOS 18+). On Android, configure androidIntentOptions with EXTRA_SPEECH_INPUT_COMPLETE_SILENCE_LENGTH_MILLIS and EXTRA_SPEECH_INPUT_POSSIBLY_COMPLETE_SILENCE_LENGTH_MILLIS to control silence detection timing. The goal is to stop recording naturally when the user pauses speaking, without requiring manual intervention.",
    "completed": true
  },
  {
    "name": "Commands dictation recording animation",
    "description": "Add a subtle animation to the microphone button while recording is in progress to provide visual feedback that the app is actively listening. Follow iOS design patterns for recording indicators: use a gentle pulsing or breathing animation (scale transform with spring physics) on the button. The animation should be continuous and smooth, using iOS-native spring physics (withSpring in react-native-reanimated) rather than linear timing. Keep the animation subtle to avoid being distracting - the goal is to provide ambient awareness that recording is active.",
    "completed": true
  },
  {
    "name": "Commands dictation stop feedback",
    "description": "Provide immediate feedback when recording stops (either manually or automatically). Add a subtle animation to the microphone button (a brief scale-down spring animation) and play a short system sound to indicate recording has ended. For the sound, use iOS system sounds via expo-av or react-native-sound - choose a gentle, non-intrusive sound similar to the iOS keyboard click or message send sound. The animation and sound should happen together to create a cohesive 'recording complete' moment. Follow iOS patterns for this type of feedback - brief, subtle, and reassuring rather than loud or jarring.",
    "completed": true
  },
  {
    "name": "Onboarding feature flag API endpoint",
    "description": "Create a backend API endpoint that returns which onboarding experience to show (original vs new conversational onboarding). The endpoint reads from a hardcoded text file in the repo (e.g., config/onboarding-flag.txt) that contains either 'original' or 'conversational'. This allows us to toggle between onboarding experiences by manually editing the text file and deploying, without needing to rebuild the mobile app. The mobile app calls this endpoint before showing onboarding to determine which flow to use.",
    "completed": true
  },
  {
    "name": "Onboarding text parsing backend endpoint",
    "description": "Create a backend endpoint that parses natural language text into pantry items and/or shopping list items using OpenAI. The endpoint accepts text input and context about what the user is describing (injected into the prompt - e.g., 'the user is listing what they have in their pantry' or 'the user is listing what they need from the store'). The endpoint can parse either type or both from the same message. For pantry items, create them with 'in_stock' status. For shopping items, create them as planned shopping list items. Return a structured response indicating what was created (e.g., { pantryItems: [...], shoppingItems: [...] }). The endpoint creates these items in the database for the user's household. Handle the case where the user explicitly says they have nothing to add (return empty lists, not an error). Return an error only if the text is unclear or completely unrelated to pantry/shopping items.",
    "completed": true,
    "note": "Decision made to reuse existing /api/commands/parse and /api/commands/execute endpoints instead of creating a separate onboarding-specific endpoint. Frontend will format user input as commands (e.g., 'add milk, eggs, bread to pantry') and orchestrate the parse + execute flow."
  },
  {
    "name": "New onboarding pantry input screen",
    "description": "Create the first screen of the new conversational onboarding that asks users what they have in their pantry. Show empathetic, encouraging copy that prompts them to just start listing items, and reassure them they can add more or change things easily later. Provide a text input (or voice input if preferred) for them to list pantry items. Include a clearly visible 'Skip' button. When they submit, immediately move to the next screen (shopping list input) without waiting for backend parsing - trigger the parsing API call in the background with context indicating this is pantry items. Store the parsing promise/request so we can wait for it later.",
    "completed": true
  },
  {
    "name": "New onboarding shopping list input screen",
    "description": "Create the second screen of the new conversational onboarding that asks users if there's anything they want to get from the store. Show empathetic copy encouraging them to list shopping items. Provide a text input (or voice input if preferred). Include a clearly visible 'Skip' button. When they submit, trigger the parsing API call in the background with context indicating this is shopping list items and immediately move to the loading/processing screen. Do not wait for the API response before navigating.",
    "completed": true
  },
  {
    "name": "New onboarding processing screen",
    "description": "Create a loading screen that shows while waiting for both pantry and shopping list parsing to complete. Display empathetic copy explaining what's happening (e.g., 'Adding your items...', 'Getting your shopping list ready...'). Show a subtle, nice animation that indicates processing is in progress (not a generic spinner - something that feels warm and engaging). Wait for both parsing requests to complete. If both succeed (or return empty lists for legitimate 'nothing to add' cases), navigate to the household invitation screen. If either fails with a true error (couldn't parse the text), show an empathetic error message explaining what happened and why, with a button to retry that specific step (pantry or shopping).",
    "completed": true,
    "note": "Implemented with warm breathing animation using spring physics. Parses and executes both pantry and shopping inputs in parallel. Shows empathetic error UI with specific retry options if either fails. Currently navigates to pantry screen on success (will be updated to household invitation screen once that's built)."
  },
  {
    "name": "New onboarding household invitation screen",
    "description": "Create a screen that prompts users to invite their household partner. Show copy explaining the value of inviting someone (shared lists, coordination, etc.). Provide an input for entering an email or phone number to send an invitation. Include a clearly visible 'Skip' button - this step is entirely optional. After submitting an invitation or skipping, navigate to the pantry screen where they can see their populated pantry and shopping list.",
    "completed": true,
    "note": "Implemented with automatic invite code generation and native Share API integration. Screen shows empathetic copy, displays invite code prominently, and includes clearly visible Skip button. Both sharing and skipping navigate to pantry screen."
  },
  {
    "name": "New onboarding household creation",
    "description": "At the start of the new conversational onboarding flow (before showing any screens), automatically create a household for the user with a default name like 'My Household'. Store the household ID so subsequent parsing endpoints can associate pantry and shopping items with this household. Users can change the household name later from settings. This creation should happen silently without requiring any user input.",
    "completed": true
  },
  {
    "name": "New onboarding flow orchestration",
    "description": "Create the main orchestrator for the new conversational onboarding experience. When the app determines it needs to show onboarding, call the feature flag API endpoint first to determine which onboarding to show. If the flag returns 'conversational', initiate the new flow: (1) create household with default name, (2) show pantry input screen, (3) show shopping input screen, (4) show processing screen, (5) show household invitation screen, (6) navigate to pantry. If the flag returns 'original', show the existing onboarding flow. Ensure the implementation allows clean toggling between the two experiences and that all state is properly managed throughout the flow.",
    "completed": true,
    "note": "Implemented orchestration for conversational vs original onboarding flows. Conversational flow auto-creates household and currently shows pantry input screen (other screens to be added as they're built). Original flow unchanged."
  },
  {
    "name": "Commands parsing comprehensive eval system",
    "description": "Expand the existing command parsing eval (commandParse.eval.ts) to include comprehensive test coverage of diverse user inputs. Add many more test cases covering: varied phrasings ('I have X', 'got some X', 'X in pantry'), plural/singular variations, common typos, informal language, regional dialects, and edge cases. Evaluate whether to use fuzzy matching (Levenshtein distance) or strict matching for validation. Consider the trade-offs: fuzzy matching is more resilient to prompt changes but requires tuning thresholds; exact matching is simpler but may need updates when prompts change. The eval should test through the API endpoint to remain resilient to implementation changes. Research whether vitest (already in use) is sufficient or if a dedicated eval/testing library would be better suited. The goal is to catch regressions when modifying the system prompt or model, ensuring consistent parsing behavior across a wide range of natural language inputs.",
    "completed": true,
    "note": "Expanded from 6 to 52 test cases. Added itemsMatch() for flexible comparison with allowAlternateItems. Tests cover varied phrasings, plurals, typos, informal language, compound items, multiple items, status variations, case variations, quantities, and context clues. Used simplified fuzzy matching (normalize + alternates) over Levenshtein. Vitest is sufficient."
  },
  {
    "name": "Commands parsing maximize empathy behavior",
    "description": "Strengthen the command parsing system prompt and add specific eval test cases to ensure maximum empathy toward user intent. When a user mentions having an item (e.g., 'I have apples', 'got milk', 'we have bread'), the system should immediately create an add_to_pantry action with appropriate status rather than returning a message asking if they want to add it. The system should always assume the user wants to take action when they mention items in the context of their pantry or shopping. Add eval test cases specifically for empathy scenarios: mentioning items without explicit 'add' commands, implicit status indicators ('almost out of X' should map to running_low), and context-dependent intents. The tone of any messages returned should be supportive and action-oriented, never questioning whether the user actually wants to do something. Update the system prompt in commandParse.ts to emphasize this empathetic, action-first approach.",
    "completed": true,
    "note": "Updated system prompt with CORE PRINCIPLE for action-first empathy and EMPATHETIC INTENT RECOGNITION mappings. Added 15 empathy scenario tests and 3 behavior validation tests. All 76 eval tests pass. System now takes action immediately when items are mentioned rather than asking for confirmation."
  },
  {
    "name": "Commands processing enhanced animation",
    "description": "Replace the basic ActivityIndicator shown during command processing with a more polished, iOS-native animation. The current implementation (line 230-238 in CommandsScreen.tsx) shows a spinner in the mic button when recordingState is 'processing'. Instead, implement a subtle animation that feels warm and engaging: use a gentle pulsing/breathing animation on the mic button with spring physics (withSpring from react-native-reanimated), possibly combined with a subtle color transition. The animation should clearly communicate that processing is happening without being distracting or anxiety-inducing. Consider adding a subtle animation to the 'Processing command...' text as well (gentle fade or scale). Follow iOS design patterns for processing states - think of how iOS handles background processing (gentle, continuous, reassuring). The goal is to make the wait feel shorter and more pleasant while maintaining clarity about what's happening.",
    "completed": true,
    "note": "Replaced ActivityIndicator with breathing animation using spring physics (scale 1→1.06→1) and synchronized opacity fade (1→0.6→1). Added subtle text opacity animation. Mic icon stays visible during processing. Animation feels warm and iOS-native."
  },
  {
    "name": "Commands feedback empathetic UI presentation",
    "description": "Replace the danger box styling currently used to display command feedback when the system doesn't understand user input. The feedback should feel like a response from someone trying to help, not an error message. Remove red/danger colors and harsh styling. Instead, use a neutral or warm color scheme with a conversational, supportive design that matches the tone of helpful guidance. The visual treatment should make the feedback feel like part of a conversation rather than a warning or failure state. Consider using a message bubble design or a subtle info card with softer styling. The goal is to make users feel supported and guided toward success, not like they've made a mistake.",
    "completed": true,
    "note": "Replaced red danger styling with soft gray message bubble design. Uses chatbubble-ellipses-outline icon and warm neutral colors (#F5F6F7, #5D6D7E) for conversational feel."
  },
  {
    "name": "Abstract voice recording into reusable VoiceInput component",
    "description": "Extract the voice recording implementation from CommandsScreen into a reusable VoiceInput component. The component should encapsulate: (1) expo-speech-recognition integration with permission handling, (2) animated mic button using react-native-reanimated with spring physics, (3) recording state management (idle, recording, processing), (4) haptic feedback on interactions, (5) visual feedback with color changes based on state, (6) status text display. The component should accept props for: onTranscriptReceived callback (called with final transcript), customizable button size/colors, optional processing state control (for when parent needs to show processing after transcript is received), error display/handling, and optional contextual strings for speech recognition. After creating this component, refactor CommandsScreen to use it. The abstraction should be flexible enough to work in different contexts (commands screen, onboarding, etc.) while maintaining the polished iOS-native feel with smooth animations and interactions.",
    "completed": true,
    "note": "Created reusable VoiceInput component with all required functionality. Refactored CommandsScreen to use it, reducing complexity from ~430 lines to ~230 lines. Component is fully customizable and ready for use in onboarding screens."
  },
  {
    "name": "Update pantry onboarding screen to use voice input",
    "description": "Replace the TextInput in NewPantryInputScreen with the new VoiceInput component. The screen should show the icon, title, and subtitle as before, but instead of a text input field, display the animated voice recording button. Update the help text to reflect voice input (e.g., 'Tap the microphone and start listing items you have'). The Continue button should be enabled after the user records something and voice transcription completes. When the user finishes recording and the transcript is received, automatically enable the Continue button (no need to wait for them to tap it - though they should have the option to re-record or skip). The transcript should be passed to onSubmit when they tap Continue, maintaining the existing behavior of triggering background parsing. Keep the Skip button visible and functional. Ensure keyboard doesn't interfere since we're no longer using text input. The voice input should feel natural and aligned with the empathetic, supportive tone of the onboarding experience.",
    "completed": true,
    "note": "Replaced TextInput with VoiceInput component. Screen now uses voice recording button instead of text input. Help text updated to guide voice input. Keyboard-related code removed. Continue button enables after transcript is received. Flow and navigation maintained."
  },
  {
    "name": "Update shopping list onboarding screen to use voice input",
    "description": "Replace the TextInput in NewShoppingListInputScreen with the new VoiceInput component, following the same pattern as the pantry screen. Show the cart icon, title, and subtitle, then the voice recording button instead of text input. Update help text to guide voice input (e.g., 'Tap the microphone and list what you need from the store'). Enable the Continue button after voice transcription completes. Pass the transcript to onSubmit when they tap Continue, maintaining background parsing behavior. Keep the Skip button visible. The implementation should mirror the pantry screen for consistency while using shopping-specific copy and the cart icon. Both onboarding screens should provide a cohesive voice-first experience that feels natural and reduces friction during initial setup.",
    "completed": true,
    "note": "Updated screen to use VoiceInput component. Removed TextInput and keyboard handling. Both onboarding screens now provide consistent voice-first experience."
  },
  {
    "name": "Pantry search icon in navigation header",
    "description": "Replace the always-visible inline search bar with a magnifying glass icon in the pantry screen's navigation header. The icon should appear to the left of the existing add (+) and settings icons. Tapping the icon triggers entry into search mode. The inline search bar is removed from the main content area. When not in search mode, the pantry list shows all items without the search input taking up space.",
    "completed": true,
    "note": "Added search icon to navigation header, removed inline search bar. Search mode state tracks when search is active. Icon color changes when search mode is active."
  },
  {
    "name": "Automatic OTA updates",
    "description": "Enable automatic over-the-air updates so users receive the latest app version without needing to go through the App Store. The app should check for updates on launch and silently download any available updates in the background. Updates are applied automatically on the next app restart with no user interaction required. This uses Expo's default update behavior - no custom UI or prompts needed. Implementation involves configuring expo-updates in app.config.js with appropriate runtime versioning and ensuring EAS Update is properly set up.",
    "completed": true
  },
  {
    "name": "Add drag handle to Settings modal",
    "description": "Add an iOS-standard drag handle (pill-shaped grabber bar) to the top of the Settings modal screen to indicate it can be dismissed by swiping down. Currently, the Settings screen is presented as a modal but lacks the visual affordance that tells users they can swipe down to dismiss. The drag handle should be a subtle, rounded pill shape centered at the top of the modal, following iOS conventions. This appears in the pantry settings screen (pantry/settings route).",
    "completed": true
  },
  {
    "name": "Add drag handle to Pantry Add Item modal",
    "description": "Add an iOS-standard drag handle (pill-shaped grabber bar) to the top of the Add Item modal screen to indicate it can be dismissed by swiping down. Currently, the Add Item screen is presented as a modal but lacks the visual affordance that tells users they can swipe down to dismiss. The drag handle should be a subtle, rounded pill shape centered at the top of the modal, following iOS conventions. This appears when adding a new pantry item (pantry/create route).",
    "completed": true
  },
  {
    "name": "Add drag handle to Pantry Edit Item modal",
    "description": "Add an iOS-standard drag handle (pill-shaped grabber bar) to the top of the Edit Item modal screen to indicate it can be dismissed by swiping down. Currently, the Edit Item screen is presented as a modal but lacks the visual affordance that tells users they can swipe down to dismiss. The drag handle should be a subtle, rounded pill shape centered at the top of the modal, following iOS conventions. This appears when editing an existing pantry item (pantry/[id] route).",
    "completed": true
  },
  {
    "name": "Smoother search overlay animation on Pantry screen",
    "description": "The search overlay animation on the Pantry screen feels too bouncy when appearing, which is inconsistent with iOS native search bar behavior. When the user taps the search icon in the header, the search bar slides down from the top but overshoots its final position before settling back. iOS native search animations (like in Settings or Mail apps) use critically-damped springs that slide smoothly without overshoot. The animation should be adjusted to feel more native and polished - a smooth, quick slide-in without the bounce. This affects the SearchOverlay component in the PantryListScreen.",
    "completed": true
  },
  {
    "name": "Move drag handle above Settings modal header",
    "description": "The drag handle on the Settings modal currently appears below the 'Settings' navigation header, which looks incorrect. The drag handle should appear at the very top of the modal, above the header, to match iOS modal presentation conventions. When users see a modal sheet, the drag handle should be the first visual element at the top edge of the sheet, not buried below the title. This requires restructuring how the Settings screen renders its header - likely using a custom header layout that includes both the drag handle and the 'Settings' title within the screen content, rather than relying on the navigation-provided header. This affects the Settings screen presented from pantry/settings route.",
    "completed": true
  },
  {
    "name": "Update dark mode success color to teal",
    "description": "Replace the current dark mode success/positive color (bright green #32D74B) with a teal/cyan color that better aligns with zottie's warm, empathetic personality. The current green feels too technical and 'hackery' - more appropriate for developer tools than a household app about cooking and meal prep. A teal/cyan maintains the positive/success meaning while feeling calmer and more modern. This affects the success color token in the design system (feedback.success in dark mode), which is used for: 'In Stock' status badges, checkmarks on completed shopping list items, success states in household join flow, and completed command indicators. The light mode success color can also be evaluated for consistency, but the primary concern is dark mode.",
    "completed": true
  },
  {
    "name": "Fix add planned item sheet dismissal navigation",
    "description": "When the 'add new planned item' bottom sheet on the shopping list screen is dismissed (by pulling down), it incorrectly navigates to the pantry screen. The expected behavior is that dismissing this sheet should keep the user on the shopping list screen where they initiated the action. This is a navigation bug that breaks the user's context - they opened the sheet from shopping list and should return to shopping list when they cancel or dismiss it.",
    "completed": true
  },
  {
    "name": "Direct swipe-to-delete on shopping list items",
    "description": "Simplify the delete interaction for shopping list items. Currently, swiping left on a shopping list item reveals a delete button that must be tapped to complete the deletion. Change this to a direct swipe-to-delete gesture: when the user swipes left past a threshold, the item should animate sliding off the screen and be deleted immediately. This reduces the deletion from a two-step action (swipe then tap) to a single gesture, making list management faster and more fluid. The slide-off animation should feel smooth and natural, providing clear feedback that the item is being removed. The implementation should follow iOS Human Interface Guidelines for destructive swipe actions (including appropriate gesture thresholds, spring animations, and visual feedback) and use zottie's design system tokens for any colors or styling to ensure consistency across the app.",
    "completed": true
  },
  {
    "name": "Shopping list tap toggles checked state",
    "description": "Tapping a shopping list item currently opens an item detail page, which interrupts the user's flow when they simply want to mark an item as bought. Change the tap behavior so that tapping an item toggles its checked/unchecked state directly without navigating anywhere. This matches the mental model users have when shopping - they want to quickly check off items as they put them in their cart. Opening a detail page for every tap creates friction and frustration, especially when users are in the store trying to move quickly through their list. The item detail page can still be accessible through a different gesture (like long-press or an edit button) if needed, but the primary tap interaction should be the quick toggle.",
    "completed": true
  },
  {
    "name": "Consistent header action icon button colors",
    "description": "The plus button in the pantry and shopping list screen headers currently uses a purple color, which is inconsistent with the other action icon buttons in the header. All header action icon buttons should use the same color for visual consistency. Update the plus button to match the color used by the other header action icons (such as search or settings icons). This affects both the pantry screen header and the shopping list screen header where the add/plus button appears.",
    "completed": true
  },
  {
    "name": "Increase header height for better touch confidence",
    "description": "The navigation headers across the app feel cramped, making it harder for users to confidently tap action buttons. The header height should be increased slightly to provide more negative space around the action icons (search, settings, add buttons). This additional breathing room helps users feel more confident they're hitting the right target, aligning with our design principle that the interface should feel 'reassuring' and avoid 'dense layouts'. The change applies to all screens with header action buttons - both large title headers on top-level screens (like Pantry, Shopping List) and standard title headers on detail/sub-screens. The icons themselves don't need to be larger; the goal is simply more vertical space in the header area so elements don't feel squeezed together.",
    "completed": true
  },
  {
    "name": "Swipe-to-reveal delete on shopping list items",
    "description": "The current direct swipe-to-delete gesture on shopping list items makes it too easy to accidentally delete items. Change the behavior so that swiping left on a shopping list item reveals a delete button (trash can icon) instead of immediately deleting the item. The user must then tap the trash can button to confirm deletion. This adds a deliberate confirmation step that prevents accidental deletions while still keeping the interaction quick and intuitive. Only the delete button should be revealed - no other action buttons. The swipe-to-reveal pattern follows standard iOS conventions for destructive actions, giving users the confidence that they won't lose items by mistake.",
    "completed": true
  },
  {
    "name": "Contextual swipe behavior for shopping list items",
    "description": "The shopping list contains two types of items: staples (recurring pantry items that auto-appear when running low) and planned items (one-time additions). Currently, swiping to delete treats both the same - permanently removing them from the pantry. This is problematic for staples because users lose their recurring item tracking. Change the swipe behavior to be contextual based on item type: when swiping a staple, mark it as 'in stock' which removes it from the shopping list but preserves it in the pantry for future use; when swiping a planned item, delete it entirely since it was a one-time purchase. No confirmation dialog or toast feedback is needed - the visual removal is sufficient feedback. This preserves the value of staples (they'll reappear when marked running low again) while keeping the quick swipe gesture intuitive for both item types.",
    "completed": true
  },
  {
    "name": "Use iOS-standard delete icon for swipe action",
    "description": "The swipe-left action on shopping list items currently displays a checkmark icon, which is confusing because tapping an item already toggles its checked state. Users expect swipe actions to be distinct from tap actions. Replace the checkmark icon with a trash/delete icon to follow iOS conventions and make the swipe action's purpose immediately clear. The underlying behavior (contextual action based on item type - marking staples as in-stock or deleting planned items) remains the same; only the visual icon changes from a checkmark to a delete/trash icon.",
    "completed": true
  },

  {
    "name": "Alphabetical Sorting for Pantry and Shopping List",
    "description": "Users need to quickly find specific items in their pantry and shopping lists, especially as lists grow longer. Currently items are ordered with recent additions at the bottom, making it difficult to locate specific items without scanning the entire list.\n\nBoth the pantry screen and shopping list screen should display items in alphabetical order (A-Z) by item name. This sorting should be automatic and consistent across both screens.\n\nWhen users view their pantry or shopping list, items appear sorted alphabetically. When new items are added, they should automatically be placed in the correct alphabetical position rather than at the top or bottom. This gives users a predictable, scannable list where they can quickly find any item by thinking \"it starts with B, so it should be near the top.\"\n\nThe alphabetical sorting applies to all items regardless of their other properties (like quantity, status, or when they were added). If item names start with the same letter, sort by subsequent letters in the standard alphabetical way.",
    "completed": true
  },
  {
    "name": "Fix Handle Position on Edit Item Modal",
    "description": "When users tap an item in the pantry screen, a modal sheet appears to edit that item. The modal has a title that says \"Item\" and a drag handle for dismissing the sheet. Currently, the drag handle appears below the title, which violates iOS design patterns where the handle should be at the very top of bottom sheets.\n\nThe drag handle should be repositioned to appear above the title \"Item\" at the top of the modal sheet. This aligns with standard iOS bottom sheet patterns where the handle is the topmost visual element, immediately indicating to users that the sheet can be dismissed by dragging down.\n\nThis is a visual layout fix that affects the edit item modal accessed from the pantry screen. The handle should be the first element users see at the top of the sheet, followed by the title below it.",
    "completed": true
  },
  {
    "name": "Clear search filter when dismissing search box",
    "description": "When users tap the dismiss button (the large X outside the search input) on the pantry search interface, the search box should both hide AND clear the active search filter. Currently there are two X buttons: a small X inside the text input that clears the search text, and a large X outside that dismisses the search box. The issue is that dismissing the search box leaves the filter active, so users see filtered results without the search box visible, which is confusing. The fix: when the dismiss button is tapped, clear the search term and remove the filter so all items are shown again.",
    "completed": true
  },
  {
    "name": "Swipe gesture to dismiss pantry search",
    "description": "Add an upward swipe gesture to dismiss the pantry search interface. Users are accustomed to dismissing modal interfaces with swipe gestures in iOS apps. When the user swipes up on the search box, it should dismiss (and follow the same behavior as tapping the dismiss X button - both hiding the search and clearing the filter).",
    "completed": true
  },
  {
    "name": "Fix edit item sheet handle position",
    "description": "On the edit item bottom sheet, the handle (drag indicator) is currently positioned below the 'Edit Item' title. This is inconsistent with the settings page, where the handle is correctly positioned above the page title. The edit item sheet should match this pattern with the handle above the title. This likely requires using a custom header similar to how the settings page is structured.",
    "completed": true
  },
  {
    "name": "Remove redundant status display on edit item page",
    "description": "The edit item page currently shows the item's status twice: once as a read-only display right below the item name, and again in the status picker below that (where the current status is highlighted). This is redundant. Remove the first status display so that only the status picker is shown, with the current status already highlighted within it.",
    "completed": true
  },
  {
    "name": "Move checked shopping list items to bottom",
    "description": "When users are actively shopping and check items off their shopping list, those checked items should automatically move to the bottom of the list. This mirrors the behavior of iOS Notes app checklists. The use case is that while shopping in-store, users check items as they put them in their cart, but don't immediately mark them as purchased. Moving checked items to the bottom keeps the unchecked (still-needed) items at the top where they're most visible and actionable. Checked items remain visible at the bottom of the list in their checked state until the user explicitly marks them as purchased (which is a separate action).",
    "completed": true
  },
  {
    "name": "Intelligent pluralization for voice commands",
    "description": "When users add items via voice commands, the backend command parser should be resilient to imperfect voice-to-text input by intelligently pluralizing common grocery items. Voice-to-text happens on-device and may not perfectly capture what the user said (e.g., missing the 's' at the end of words). The parser should recognize that people typically buy 'eggs' not 'egg', 'tomatoes' not 'tomato', 'grapes' not 'grape', etc. When processing voice commands (not typed commands), if the parsed item name is a common grocery item that's typically purchased in plural form, the parser should automatically adjust it to the plural form before adding it to the user's list. This makes the voice command experience more natural and robust against environmental factors beyond our control.",
    "completed": true,
    "skipped": true
  },
  {
    "name": "(Assistant Epic) Add Assistant tab with voice button and canned prompts",
    "description": "Add a new 'Assistant' tab to the app alongside existing tabs (does NOT replace the Commands tab). When opened, the tab shows a prominent voice input button at the top, followed by 3-4 canned prompt buttons for common actions like 'Update pantry items', 'Help me plan meals', and 'Add to shopping list'. Nothing needs to be functional yet - the voice button and prompt buttons are just UI placeholders. This PRD is only about getting the tab in place with the visual elements.",
    "completed": true
  },
  {
    "name": "(Assistant Epic) Enable voice input on Assistant tab",
    "description": "Make the voice button on the Assistant tab functional. User can tap the voice button, speak, and see their transcribed text appear on screen. This PRD is just about capturing and displaying voice input - no LLM response yet.",
    "completed": true
  },
  {
    "name": "(Assistant Epic) Connect Assistant to streaming LLM backend",
    "description": "Send the user's voice input (or canned prompt) to an LLM backend and display the streaming response. Responses should appear word-by-word as they're generated. The LLM should have context of the user's pantry and shopping list data so it can answer questions about their groceries. This is read-only - the assistant can answer questions but cannot take actions yet.",
    "completed": true
  },
  {
    "name": "(Assistant Epic) Enable canned prompt buttons on Assistant tab",
    "description": "Make the canned prompt buttons functional. When user taps a button like 'Update pantry items' or 'Help me plan meals', it sends that prompt to the LLM and starts a guided conversation focused on that task.",
    "completed": true
  },
  {
    "name": "(Assistant Epic) Add human-in-the-loop tool calling to Assistant",
    "description": "Allow the Assistant to propose actions like adding items, marking things out of stock, or updating the shopping list. When the assistant wants to take an action, it shows the user what it plans to do and asks for confirmation before executing. User can approve or reject the proposed actions.",
    "completed": true
  },
  {
    "name": "(Assistant Epic) Add text input option to Assistant tab",
    "description": "Add a secondary text input field to the Assistant tab for when voice isn't convenient. Voice remains the primary interaction method, but users can also type their requests.",
    "completed": true
  },
  {
    "name": "(Assistant Epic) Add conversation history to Assistant tab",
    "description": "Display conversation history in the Assistant tab so users can have multi-turn conversations. History persists during the app session (survives tab switches) but clears when the app restarts or user taps New conversation. Fresh pantry context is included with each request so the assistant sees any changes made mid-conversation.",
    "completed": true
  },
  {
    "name": "Move Mark as Purchased action to header",
    "description": "The 'Mark as Purchased' button currently appears at the bottom of the shopping list as soon as any item is checked, and it's too prominent and in-the-way while actively shopping. Move this action to the header/navigation area so it's accessible but doesn't obstruct scrolling through the list.",
    "completed": true
  },
  {
    "name": "Add choice when removing item from shopping list",
    "description": "When a user swipes to remove an item from the shopping list, show two options: 'Already have it' and 'Don't want to buy it'. If they choose 'Already have it', the item is marked as in-stock in the pantry. If they choose 'Don't want to buy it', the item is removed from the shopping list without changing its pantry status - it goes into a dormant state so it won't keep reappearing on the shopping list. This addresses the case where someone buys salmon occasionally but doesn't want it automatically added to their shopping list every time they run out.",
    "completed": true
  },
  {
    "name": "Pulsing loading state for status change buttons",
    "description": "When the user changes an item's status on the edit item screen, the current behavior replaces all status buttons with a loader, causing a jarring flash. Instead, keep all buttons visible and show a subtle pulsing/breathing animation on the selected button until the API confirms the change. This provides feedback that the action is in progress without hiding the interface or causing visual disruption.",
    "completed": true
  },
  {
    "name": "Fix item name alignment on edit item screen",
    "description": "On the edit item screen, the item name at the top is misaligned - it sits too far to the left compared to the other sections below it (details, change status). The item name should align horizontally with the content in the sections below it for visual consistency.",
    "completed": true
  },
  {
    "name": "Simplify details section on edit item screen",
    "description": "The details section on the edit item screen currently shows redundant information: the item name (already displayed prominently at the top) and the status (already shown in the status picker above). Remove the item name and status from the details section, keeping only the useful information like last purchased date.",
    "completed": true
  },
  {
    "name": "Remove Edit Item header title and fix Settings header spacing",
    "description": "Two header adjustments for bottom sheet modals: (1) On the edit item screen, remove the 'Edit Item' title entirely - it's redundant since the item name is already visible and serves as the contextual header. (2) On the settings screen, keep the 'Settings' title but add more vertical space between the drag handle at the top of the modal and the 'Settings' text below it.",
    "completed": true
  },
  {
    "name": "Add confirmation before marking items as purchased",
    "description": "When the user taps the checkout button in the shopping list header, the app currently marks all checked items as purchased immediately. This is risky - an accidental tap can mark items as purchased before the user is ready. Add a confirmation step that asks the user to confirm before completing the action. The implementer should research iOS Human Interface Guidelines to determine the appropriate confirmation pattern (alert vs action sheet vs other) for this type of important action.",
    "completed": true
  },
  {
    "name": "Move delete action to overflow menu on item detail",
    "description": "The item detail bottom sheet currently has a large red delete button at the bottom that's visually prominent and takes up significant space. This is unnecessary visual weight since users don't need to see the delete option every time they view item details. Move the delete action into an overflow menu accessible from a button in the header area of the bottom sheet. The implementer should follow iOS Human Interface Guidelines to determine the appropriate icon and placement for the overflow menu (commonly an ellipsis icon in the top-right). The delete action should still show a confirmation before executing.",
    "completed": true
  },
  {
    "name": "Move edit name action to overflow menu on item detail",
    "description": "Currently users tap directly on the item name to edit it, which isn't very discoverable. Add an 'Edit Name' option to the overflow menu in the item detail header (same menu where delete lives). The implementer should determine the best UX for what happens when the user taps 'Edit Name' - options include: inline editing where the name becomes editable in place, a separate modal/sheet with a text input, or another pattern that follows iOS conventions. The goal is a clear, intentional way to edit the item name.",
    "completed": true
  },
  {
    "name": "Improve tab bar selected state visibility",
    "description": "The current tab bar's selected state is too subtle - the color difference between active and inactive tabs isn't noticeable enough for users to quickly see which tab they're on. Improve the visual distinction between selected and unselected tabs. The implementer should consider iOS-standard approaches such as using filled icons for the selected tab and outline icons for unselected tabs, adjusting the color contrast, or adding other visual indicators that make the selected state immediately obvious.",
    "completed": true
  },
  {
    "name": "(Assistant Epic) Make Assistant responses brief and plain-text",
    "description": "The Assistant on the Assistant tab is currently too verbose and uses markdown formatting that renders as raw text in the chat UI. Update the Assistant's response style to be brief (just a few sentences at most) and use only plain text without any markdown formatting. The tone should remain the same - supportive and empathetic per the app's UX principles - just more concise. Responses should feel conversational and quick, not like reading documentation. This applies to all Assistant responses including answers to questions, confirmations of actions, and guided conversations from canned prompts.",
    "completed": true
  },
  {
    "name": "Remove item type label from shopping list",
    "description": "The shopping list currently shows 'Staple' or 'Planned' as a label underneath each item name. This is unnecessary UI clutter - users don't need to see this internal classification while they're actively shopping. Remove the item type label from shopping list items to keep the interface clean and focused on what matters: the item name and its status.",
    "completed": true
  },
  {
    "name": "(Onboarding Epic) Simplify onboarding to shopping list only",
    "description": "Streamline the onboarding flow to focus solely on the shopping list, removing both the pantry input step and the household invitation step. The new flow: user is asked 'What do you need from the store?', speaks their shopping list items via voice input, sees a brief processing screen, then lands directly in the app. This gets users to value faster - they can immediately use their shopping list without the upfront friction of documenting their entire pantry. The pantry setup becomes a separate, contextual experience (see companion PRD). The household invite feature remains accessible from settings for users who want to share lists later.",
    "completed": true
  },
  {
    "name": "(Onboarding Epic) Pantry contextual onboarding card",
    "description": "Add an onboarding card to the Pantry tab that appears when the user has no in-stock items. This card pitches the value of filling out their pantry: 'Tell me what's in your pantry and I can help you figure out what to make for dinner, remind you when you're running low, and keep your shopping list updated automatically.' The card includes a prominent voice input button (reusing the voice input pattern from onboarding) so users can speak their pantry items naturally. The card persists until the user has added at least one in-stock item - there is no manual dismiss option. This creates a gentle but consistent nudge toward the pantry setup while letting users engage with it when they're ready, rather than forcing it during initial onboarding. If the pantry has planned items (from the shopping list) but no in-stock items, those planned items should still be visible below the onboarding card.",
    "completed": true
  },
  {
    "name": "(Onboarding Epic) Land users on Shopping tab after onboarding",
    "description": "After completing the onboarding voice input flow, land users on the Shopping tab instead of the Pantry tab. Users just told us what they need from the store - they should immediately see those items on their shopping list where they expect them. This creates a clear mental model: 'I said what I need to buy, and here's my list.' The Pantry tab remains accessible via navigation for users who want to explore it.",
    "completed": true
  },
  {
    "name": "(Onboarding Epic) Clarify onboarding prompt language",
    "description": "Update the onboarding voice input screen prompt from 'What do you need from the store?' to 'What should we add to your shopping list?' This language directly connects user intent to where their items will appear, reducing confusion about the relationship between what they say and what they see in the app.",
    "completed": true
  },
  {
    "name": "(Education Epic) First status change teaches shopping list connection",
    "description": "When a user marks an item as 'running low' or 'out of stock' for the first time ever, show brief feedback explaining that this item now appears on their shopping list. This teaches the core value loop: changes in your pantry automatically update your shopping list. The feedback should be dismissible and only appear once (first time across the user's lifetime, not per-item). This is the 'aha moment' where users understand why tracking pantry status matters.",
    "completed": true
  },
  {
    "name": "(Education Epic) Instructional shopping list empty state",
    "description": "Update the Shopping tab empty state to guide users on how items get added. Change the current copy from 'Items that are running low or out of stock will appear here' to something more actionable like 'Mark items in your Pantry as running low to add them here, or tap + to add items directly.' The empty state should teach users the connection between pantry status and shopping list rather than just describing what appears here passively.",
    "completed": true
  },
  {
    "name": "(Assistant Epic) Include last purchase date in Assistant context",
    "description": "Give the AI Assistant access to the last purchase date for items it reasons about. This helps the assistant understand item freshness when answering questions or making suggestions. For example, if a user asks 'should I buy more milk?', the assistant can factor in that they last purchased milk 2 weeks ago. The last purchase date should be included in the context for any items the assistant is reasoning about - whether they're currently in the pantry, on the shopping list, or just mentioned in the conversation. This is backend-only; the last purchase date doesn't need to be displayed in the app UI.",
    "completed": true
  },
  {
    "name": "(Assistant Epic) Anchor input at bottom of chat",
    "description": "Move the Assistant's input controls to the bottom of the screen following standard chat app conventions. The input area should contain a text field and a microphone button to the right of it. Tapping the text field lets users type their message. Tapping the microphone button starts voice recording; tapping it again stops recording and inserts the transcription into the input. This replaces the current inline 'type a follow-up' element that appears after messages in the middle of the chat.",
    "completed": true
  },
  {
    "name": "(Assistant Epic) Standard chat scroll behavior",
    "description": "Update the Assistant chat to use standard chat scroll behavior where new messages appear at the bottom and older messages scroll upward. The view should stay anchored to the bottom so users always see the latest messages. As the assistant streams its response, the view should auto-scroll to keep the new content visible.",
    "completed": true
  },
  {
    "name": "(Assistant Epic) Add new conversation button to header",
    "description": "Add a button in the top-right of the Assistant tab header that starts a new conversation. Tapping it clears the current conversation history and returns to a fresh chat state. This gives users an explicit way to start over rather than having conversations auto-clear or persist indefinitely.",
    "completed": true
  },
  {
    "name": "Remove Commands tab and related code",
    "description": "Remove the Commands tab entirely from the app, along with all related code and backend endpoints. The Assistant feature has replaced the Commands functionality. This includes: removing the Commands tab from navigation, deleting the Commands UI components, removing any backend endpoints that were exclusively used by the Commands feature, and cleaning up any related state management or hooks. Before deleting, verify that no code is shared with the Assistant feature - the implementer should check for any dependencies between Commands and Assistant to ensure nothing breaks. If shared utilities or components are found, they should be preserved and only the Commands-specific code removed.",
    "completed": true
  },
  {
    "name": "Display dormant items in separate section at bottom of pantry",
    "description": "On the pantry list screen, items with 'dormant' status should be visually separated from active pantry items and displayed at the bottom of the list in their own section. This keeps the main pantry view focused on items the user is actively tracking while still giving visibility to dormant items (things they own but don't intend to repurchase). The dormant section should be clearly labeled so users understand why these items are separated. Dormant items remain tappable to view/edit details. Note: dormancy is independent of stock status - an item can be 'running low' AND dormant (user has some left but doesn't plan to buy more).",
    "completed": true
  },
  {
    "name": "Swipe to toggle dormancy on pantry items",
    "description": "Add a swipe gesture on pantry list items to toggle dormancy. When swiping on a non-dormant item, the action should mark it as dormant. When swiping on a dormant item (in the dormant section), the action should reactivate it (remove dormancy). This provides a quick way to manage dormancy without opening the item detail screen. The swipe action should be visually distinct from any existing swipe actions and clearly communicate what will happen.",
    "completed": true
  },
  {
    "name": "Add dormancy toggle to item detail screen",
    "description": "Add a way to toggle an item's dormancy from the item detail bottom sheet. This should be separate from the status picker (in-stock, running low, out of stock) since dormancy is an independent attribute - an item can be both 'running low' AND dormant. Users should be able to mark any item as dormant regardless of its current stock status, and should be able to reactivate dormant items from this screen as well.",
    "completed": true
  },
  {
    "name": "Dismiss settings modal on logout",
    "description": "When the user taps the logout button from the settings screen, the settings modal should automatically dismiss as part of the logout flow. Currently, the logout action completes but the settings modal stays open, requiring the user to manually dismiss it before seeing the sign-in screen. The modal should close seamlessly so the user transitions directly from the settings screen to the sign-in screen without any extra interaction.",
    "completed": true
  },
  {
    "name": "Remove iOS auth permission prompt on sign-in/sign-out",
    "description": "On iOS, users currently see a system prompt saying 'zottie wants to use auth0.com to Sign In' with Cancel and Continue buttons every time they sign in or sign out. This prompt should be eliminated to create a smoother authentication experience. The solution is to enable ephemeral sessions in the Auth0 configuration by passing ephemeralSession: true to the authorize call. This tells iOS to use a private browser session instead of the shared Safari cookie jar, which bypasses the permission prompt. Trade-off: SSO across apps will not work, but this is acceptable for a standalone mobile app. For logout on iOS, use clearCredentials() instead of clearSession() to avoid the prompt appearing during sign-out as well.",
    "completed": true
  },
  {
    "name": "Consistent list spacing across Shopping List and Pantry",
    "description": "Standardize the spacing and padding across the Shopping List and Pantry screens to create visual consistency when switching between tabs. Currently, the Shopping List has more space between the header and the start of the list content, while the Pantry has tighter spacing. There are also differences in padding between individual list items. Apply the Shopping List's spacing pattern to the Pantry screen so both screens feel like parts of the same cohesive app. This includes: consistent spacing between the header and the first list item, and consistent vertical padding between list items (accounting for the fact that Shopping List items are taller due to checkboxes).",
    "completed": true
  },
  {
    "name": "Settings gear accessible from all main tab screens",
    "description": "Make the settings gear icon accessible from all main tab screens (Shopping List, Pantry, Assistant), not just the Pantry. The settings gear should appear in the top left corner of each main tab screen's header. Tapping it opens the same settings modal that currently exists. This may require reorganizing how settings is implemented - currently it lives within the Pantry routes, but it should become a shared component that any main tab screen can access. Sub-screens (like item detail views) should not show the settings gear.",
    "completed": true
  },
  {
    "name": "Lightweight command parse endpoint",
    "description": "Add a /api/commands/parse endpoint that takes natural language text and returns structured pantry actions. This is a focused, non-conversational endpoint designed for quick item addition - it extracts item names from speech like 'cherries, grapes, and some milk' and returns actions that can be passed to /api/commands/execute. It should handle status hints in the input (e.g., 'running low on eggs' -> status: running_low). This endpoint is simpler and faster than routing through the full assistant - no conversation history, no streaming, just text-in/actions-out. It powers both the pantry onboarding card (currently broken with a 404) and the persistent voice-add button. The mobile app already has client code expecting this endpoint to exist.",
    "completed": true
  },
  {
    "name": "Persistent voice-add button on Pantry screen",
    "description": "Add a microphone button to the Pantry screen header that allows users to quickly add items via voice at any time, not just during onboarding. When tapped, the button starts voice recording; tapping again stops recording and processes the spoken items. The voice input uses the lightweight parse endpoint to extract items from natural speech (e.g., 'cherries, grapes, and some milk') and adds them directly to the pantry without requiring a full assistant conversation. Items are auto-added for speed - no confirmation step. This solves the problem that currently voice input only exists in the onboarding card, which disappears once the user has pantry items. Users who prefer voice input should be able to keep using it for ongoing additions without switching to the Assistant tab.",
    "completed": true
  },
  {
    "name": "(Go-tos Epic) Go-tos management UI",
    "description": "Add a new 'Go-tos' tab where users can save and manage go-to meals - dishes they know how to make and want quick access to. Go-tos are shared at the household level: all household members see the same go-tos and can create, edit, or delete any of them. Each go-to has a name, a freeform text field describing what's needed to make it (ingredients, amounts, notes), and tracks who created it. The data structure: name string, 'needs' text string, and createdBy user reference. The list screen shows cards with the go-to name, a truncated preview of the needs text, and subtle attribution showing who created it (e.g., 'by Chester' or a small avatar). Tapping a card opens the edit screen. The create/edit screen has two fields: a name input at the top, then a 'needs' label followed by a multiline text area. This creates a natural sentence structure: '[Name] needs [ingredients text]'. The text input includes a microphone button for voice input - users can tap to record and speak their ingredients naturally, which transcribes into the text field. A delete option appears at the bottom of the edit screen. The plus button in the header creates a new go-to (attributed to the current user). This tab serves as the foundation for go-tos - users can create and manage them here, and later the Assistant will gain the ability to use this data when helping with shopping lists.",
    "completed": true
  },
  {
    "name": "(Go-tos Epic) Assistant integration for go-tos",
    "description": "Give the Assistant awareness of the user's saved go-tos so it can help with meal planning and shopping. The Assistant should be able to: (1) Use go-tos when adding to shopping list - when a user says 'add what I need for pork and beans', the Assistant looks up that go-to, checks the pantry for what's already in stock, and adds only the missing items to the shopping list. The Assistant should confirm what was added and mention if anything was skipped because it's already in the pantry. (2) Reference go-tos in general conversation - the Assistant should know what go-tos exist so it can suggest them or answer questions like 'what do I need to make my stir fry?' The go-to's 'needs' field is freeform text, so the Assistant interprets it contextually - it can handle specific items ('pinto beans'), vague descriptions ('some kind of protein'), and quantity hints ('lots of butter'). When checking pantry status against quantity hints, the Assistant should warn if an item is running low and the go-to needs 'a lot' of it. To create, edit, or delete go-tos, users go to the Go-tos tab.",
    "completed": true
  }
]
